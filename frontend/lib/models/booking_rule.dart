import '../services/settings_service.dart';

class BookingType {
  static const String regular = 'regular'; // ‡∏à‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
  static const String activity = 'activity'; // ‡∏à‡∏≠‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°
}

class BookingRule {
  // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ï‡πà‡∏≠‡∏ß‡∏±‡∏ô
  static const int maxOutdoorBookingsPerDay = 1;
  static const int maxIndoorBookingsPerDay = 1;
  static const int maxHoursPerBooking = 1;
  
  // ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤ (‡πÄ‡∏î‡∏∑‡∏≠‡∏ô) - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°
  static const int maxAdvanceBookingMonths = 2;
  
  // ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á (22:00)
  static const String bookingCloseTime = '22:00';
  
  // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  static Future<bool> canMakeBooking({
    required String bookingType, // 'regular' ‡∏´‡∏£‡∏∑‡∏≠ 'activity'
    required DateTime selectedDate,
    required String courtType, // 'outdoor' ‡∏´‡∏£‡∏∑‡∏≠ 'indoor'
    required List<Map<String, dynamic>> existingBookings,
    required String selectedTimeSlot,
  }) async {
    // ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡πà‡∏≠‡∏ô - ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏™‡∏°‡∏≠
    final isTestMode = await SettingsService.isTestModeEnabled();
    if (isTestMode) {
      print('üß™ [BookingRule] Test mode enabled - bypassing all booking restrictions');
      return true; // ‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏î‡∏™‡∏≠‡∏ö
    }

    // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á (22:00)
    if (!(await isBookingTimeValid())) {
      return false;
    }

    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    if (!(await isValidBookingDate(selectedDate, bookingType))) {
      return false;
    }

    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏•‡∏¢‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!(await isTimeSlotStillAvailable(selectedDate, selectedTimeSlot))) {
      return false;
    }

    // ‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏õ‡∏Å‡∏ï‡∏¥ - ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
    if (bookingType == BookingType.regular) {
      final today = DateTime.now();
      final todayOnly = DateTime(today.year, today.month, today.day);
      final selectedOnly = DateTime(selectedDate.year, selectedDate.month, selectedDate.day);
      
      if (!selectedOnly.isAtSameMomentAs(todayOnly)) {
        return false; // ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
      }
      
      // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á (‡∏à‡∏≥‡∏Å‡∏±‡∏î 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡πà‡∏≠‡∏ß‡∏±‡∏ô)
      if (hasBookingTodayAlready(existingBookings, selectedDate)) {
        return false;
      }
    }

    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ã‡πâ‡∏≥‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
    if (hasConflictingBooking(
      selectedDate: selectedDate,
      courtType: courtType,
      existingBookings: existingBookings,
      selectedTimeSlot: selectedTimeSlot,
    )) {
      return false;
    }

    return true;
  }

  // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏¢‡∏±‡∏á‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏¢‡πÄ‡∏ß‡∏•‡∏≤‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß)
  static Future<bool> isTimeSlotStillAvailable(DateTime selectedDate, String timeSlot) async {
    // ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡πà‡∏≠‡∏ô - ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ß‡∏•‡∏≤
    final isTestMode = await SettingsService.isTestModeEnabled();
    if (isTestMode) {
      print('üß™ [BookingRule] Test mode enabled - all time slots available');
      return true;
    }

    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final selectedDay = DateTime(selectedDate.year, selectedDate.month, selectedDate.day);
    
    // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ
    if (selectedDay.isAfter(today)) {
      return true;
    }
    
    // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ
    if (selectedDay.isBefore(today)) {
      return false;
    }
    
    // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏ß‡∏•‡∏≤
    final timeSlotParts = timeSlot.split('-');
    final startTimeStr = timeSlotParts[0];
    final timeParts = startTimeStr.split(':');
    final startHour = int.parse(timeParts[0]);
    final startMinute = int.parse(timeParts[1]);
    
    final currentTime = now.hour * 60 + now.minute;
    final timeSlotStart = startHour * 60 + startMinute;
    
    // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏•‡∏¢‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á‡∏ä‡πà‡∏ß‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß ‡∏à‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ
    return currentTime < timeSlotStart;
  }

  // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≠‡∏á‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
  static bool hasBookingTodayAlready(List<Map<String, dynamic>> existingBookings, DateTime selectedDate) {
    final selectedDateStr = "${selectedDate.year}-${selectedDate.month.toString().padLeft(2, '0')}-${selectedDate.day.toString().padLeft(2, '0')}";
    
    for (var booking in existingBookings) {
      final bookingDate = booking['date'];
      final status = booking['status'];
      
      // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å (‡πÑ‡∏°‡πà‡∏ô‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÅ‡∏•‡πâ‡∏ß)
      if (bookingDate == selectedDateStr && status != 'cancelled' && status != 'expired') {
        return true;
      }
    }
    
    return false;
  }

  // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á
  static Future<bool> isBookingTimeValid() async {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö test mode ‡∏Å‡πà‡∏≠‡∏ô
    final isTestMode = await SettingsService.isTestModeEnabled();
    
    if (isTestMode) {
      return true; // ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô test mode
    }
    
    final now = DateTime.now();
    final closeTime = _parseTime(bookingCloseTime);
    final todayCloseTime = DateTime(
      now.year, 
      now.month, 
      now.day, 
      closeTime.hour, 
      closeTime.minute
    );
    
    return now.isBefore(todayCloseTime);
  }

  // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ
  static Future<bool> isValidBookingDate(DateTime selectedDate, String bookingType) async {
    // ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡πà‡∏≠‡∏ô - ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏ß‡∏±‡∏ô
    final isTestMode = await SettingsService.isTestModeEnabled();
    if (isTestMode) {
      print('üß™ [BookingRule] Test mode enabled - all dates are valid for booking');
      return true;
    }

    final today = DateTime.now();
    final todayOnly = DateTime(today.year, today.month, today.day);
    final selectedOnly = DateTime(selectedDate.year, selectedDate.month, selectedDate.day);
    
    // ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÑ‡∏î‡πâ
    if (selectedOnly.isBefore(todayOnly)) {
      return false;
    }

    // ‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏õ‡∏Å‡∏ï‡∏¥ - ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
    if (bookingType == BookingType.regular) {
      return selectedOnly.isAtSameMomentAs(todayOnly);
    }
    
    // ‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏° - ‡∏à‡∏≠‡∏á‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤‡πÑ‡∏î‡πâ 1-2 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô
    if (bookingType == BookingType.activity) {
      final minAdvanceDate = DateTime(today.year, today.month + 1, today.day);
      final maxAdvanceDate = DateTime(today.year, today.month + maxAdvanceBookingMonths, today.day);
      
      return selectedOnly.isAfter(minAdvanceDate.subtract(Duration(days: 1))) &&
             selectedOnly.isBefore(maxAdvanceDate.add(Duration(days: 1)));
    }

    return false;
  }

  // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ã‡πâ‡∏≥
  static bool hasConflictingBooking({
    required DateTime selectedDate,
    required String courtType,
    required List<Map<String, dynamic>> existingBookings,
    required String selectedTimeSlot,
  }) {
    final selectedDateStr = "${selectedDate.year}-${selectedDate.month.toString().padLeft(2, '0')}-${selectedDate.day.toString().padLeft(2, '0')}";
    
    for (var booking in existingBookings) {
      final bookingDate = booking['date'];
      final bookingCourtType = booking['courtType'];
      final bookingTimeSlots = List<String>.from(booking['timeSlots'] ?? []);
      final status = booking['status'];
      
      // ‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡πâ‡∏ß
      if (status == 'cancelled' || status == 'expired') {
        continue;
      }
      
      // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      if (bookingDate == selectedDateStr) {
        // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏™‡∏ô‡∏≤‡∏°‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if (bookingCourtType == courtType) {
          // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÉ‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏™‡∏ô‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß
          final maxBookings = courtType == 'outdoor' ? maxOutdoorBookingsPerDay : maxIndoorBookingsPerDay;
          if (maxBookings <= 1) {
            return true; // ‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÉ‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏™‡∏ô‡∏≤‡∏°‡∏ô‡∏µ‡πâ
          }
        }
        
        // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á‡∏Å‡∏±‡∏ö‡πÉ‡∏ô‡∏£‡πà‡∏°
        if (bookingCourtType != courtType && hasTimeOverlap(bookingTimeSlots, [selectedTimeSlot])) {
          return true; // ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ô
        }
      }
    }
    
    return false;
  }

  // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô
  static bool hasTimeOverlap(List<String> timeSlots1, List<String> timeSlots2) {
    for (String slot1 in timeSlots1) {
      for (String slot2 in timeSlots2) {
        if (slot1 == slot2) {
          return true;
        }
        
        // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô
        final slot1Parts = slot1.split('-');
        final slot2Parts = slot2.split('-');
        
        if (slot1Parts.length == 2 && slot2Parts.length == 2) {
          final slot1Start = _parseTime(slot1Parts[0]);
          final slot1End = _parseTime(slot1Parts[1]);
          final slot2Start = _parseTime(slot2Parts[0]);
          final slot2End = _parseTime(slot2Parts[1]);
          
          // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
          if (slot1Start.isBefore(slot2End) && slot2Start.isBefore(slot1End)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏à‡∏≤‡∏Å String ‡πÄ‡∏õ‡πá‡∏ô DateTime
  static DateTime _parseTime(String timeStr) {
    final parts = timeStr.split(':');
    final hour = int.parse(parts[0]);
    final minute = int.parse(parts[1]);
    return DateTime(2000, 1, 1, hour, minute);
  }

  // ‡πÑ‡∏î‡πâ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
  static Future<String> getBookingErrorMessage({
    required String bookingType,
    required DateTime selectedDate,
    required String courtType,
    required List<Map<String, dynamic>> existingBookings,
    required String selectedTimeSlot,
  }) async {
    // ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡πà‡∏≠‡∏ô - ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ error message
    final isTestMode = await SettingsService.isTestModeEnabled();
    if (isTestMode) {
      print('üß™ [BookingRule] Test mode enabled - no error message should be shown');
      return ''; // ‡πÑ‡∏°‡πà‡∏°‡∏µ error message ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏î‡∏™‡∏≠‡∏ö
    }

    // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á
    if (!(await isBookingTimeValid())) {
      return '‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏à‡∏≠‡∏á‡πÉ‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ 09:00-22:00 ‡∏ô.';
    }

    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà
    if (!(await isValidBookingDate(selectedDate, bookingType))) {
      if (bookingType == BookingType.regular) {
        return '‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏õ‡∏Å‡∏ï‡∏¥‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô';
      } else {
        return '‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏≠‡∏á‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤ 1-2 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô';
      }
    }

    // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏¢‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß
    if (!(await isTimeSlotStillAvailable(selectedDate, selectedTimeSlot))) {
      final now = DateTime.now();
      final today = DateTime(now.year, now.month, now.day);
      final selectedDay = DateTime(selectedDate.year, selectedDate.month, selectedDate.day);
      
      if (selectedDay.isBefore(today)) {
        return '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÑ‡∏î‡πâ';
      } else {
        final timeSlotParts = selectedTimeSlot.split('-');
        final startTime = timeSlotParts[0];
        return '‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤ $startTime ‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ';
      }
    }

    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß
    if (bookingType == BookingType.regular && hasBookingTodayAlready(existingBookings, selectedDate)) {
      return '‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏à‡∏≠‡∏á‡∏™‡∏ô‡∏≤‡∏°‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß (‡∏à‡∏≥‡∏Å‡∏±‡∏î 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡πà‡∏≠‡∏ß‡∏±‡∏ô)';
    }

    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ã‡πâ‡∏≥
    final selectedDateStr = "${selectedDate.year}-${selectedDate.month.toString().padLeft(2, '0')}-${selectedDate.day.toString().padLeft(2, '0')}";
    
    for (var booking in existingBookings) {
      final bookingDate = booking['date'];
      final bookingCourtType = booking['courtType'];
      final bookingTimeSlots = List<String>.from(booking['timeSlots'] ?? []);
      final status = booking['status'];
      
      // ‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡πâ‡∏ß
      if (status == 'cancelled' || status == 'expired') continue;
      
      if (bookingDate == selectedDateStr) {
        if (bookingCourtType == courtType) {
          final courtTypeName = courtType == 'outdoor' ? '‡∏™‡∏ô‡∏≤‡∏°‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á' : '‡∏™‡∏ô‡∏≤‡∏°‡πÉ‡∏ô‡∏£‡πà‡∏°';
          return '‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏à‡∏≠‡∏á$courtTypeName‡πÅ‡∏•‡πâ‡∏ß 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ (‡∏à‡∏≥‡∏Å‡∏±‡∏î 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡πà‡∏≠‡∏ß‡∏±‡∏ô)';
        }
        
        if (bookingCourtType != courtType && hasTimeOverlap(bookingTimeSlots, [selectedTimeSlot])) {
          final otherCourtType = bookingCourtType == 'outdoor' ? '‡∏™‡∏ô‡∏≤‡∏°‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏à‡πâ‡∏á' : '‡∏™‡∏ô‡∏≤‡∏°‡πÉ‡∏ô‡∏£‡πà‡∏°';
          return '‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏à‡∏≠‡∏á$otherCourtType‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß';
        }
      }
    }

    return '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á';
  }
}
